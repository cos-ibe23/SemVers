import { pgTable, text, timestamp, boolean, varchar } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-zod';
import { z } from 'zod';
import { UserRoles } from '../../permissions/types';

// Better Auth managed tables
// These are generated by Better Auth CLI: npm run db:better-auth:generate

export const user = pgTable('user', {
    id: text('id').primaryKey(),
    name: text('name').notNull(),
    email: text('email').notNull().unique(),
    emailVerified: boolean('email_verified').notNull().default(false),
    image: text('image'),
    role: text('role').notNull().default(UserRoles.CLIENT),
    isSystemUser: boolean('is_system_user').notNull().default(false),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    updatedAt: timestamp('updated_at').notNull().defaultNow(),

    // Business/profile fields (any user can have business info)
    businessName: varchar('business_name', { length: 255 }),
    logoUrl: varchar('logo_url', { length: 512 }),
    street: varchar('street', { length: 255 }),
    city: varchar('city', { length: 100 }),
    state: varchar('state', { length: 100 }),
    country: varchar('country', { length: 100 }),
    phoneCountryCode: varchar('phone_country_code', { length: 10 }),
    phoneNumber: varchar('phone_number', { length: 20 }),

    // Shipper-specific fields
    requestSlug: varchar('request_slug', { length: 100 }).unique(), // for public pickup request link
    onboardedAt: timestamp('onboarded_at'), // when shipper completed onboarding
});

// Zod schemas for user
export const selectUserSchema = createSelectSchema(user);

// Response schema for API responses (dates as ISO strings)
export const userResponseSchema = z.object({
    id: z.string(),
    name: z.string(),
    email: z.string(),
    emailVerified: z.boolean(),
    image: z.string().nullable(),
    role: z.string(),
    isSystemUser: z.boolean(),
    createdAt: z.coerce.date().transform((d) => d.toISOString()),
    updatedAt: z.coerce.date().transform((d) => d.toISOString()),
    businessName: z.string().nullable(),
    logoUrl: z.string().nullable(),
    street: z.string().nullable(),
    city: z.string().nullable(),
    state: z.string().nullable(),
    country: z.string().nullable(),
    phoneCountryCode: z.string().nullable(),
    phoneNumber: z.string().nullable(),
    requestSlug: z.string().nullable(),
    onboardedAt: z.coerce.date().nullable().transform((d) => d?.toISOString() ?? null),
});

export type UserResponse = z.infer<typeof userResponseSchema>;

export const session = pgTable('session', {
    id: text('id').primaryKey(),
    userId: text('user_id')
        .notNull()
        .references(() => user.id, { onDelete: 'cascade' }),
    token: text('token').notNull().unique(),
    expiresAt: timestamp('expires_at').notNull(),
    ipAddress: text('ip_address'),
    userAgent: text('user_agent'),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const account = pgTable('account', {
    id: text('id').primaryKey(),
    userId: text('user_id')
        .notNull()
        .references(() => user.id, { onDelete: 'cascade' }),
    accountId: text('account_id').notNull(),
    providerId: text('provider_id').notNull(), // 'google', 'credential', etc.
    accessToken: text('access_token'),
    refreshToken: text('refresh_token'),
    accessTokenExpiresAt: timestamp('access_token_expires_at'),
    refreshTokenExpiresAt: timestamp('refresh_token_expires_at'),
    scope: text('scope'),
    idToken: text('id_token'),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    updatedAt: timestamp('updated_at').notNull().defaultNow(),
});

export const verification = pgTable('verification', {
    id: text('id').primaryKey(),
    identifier: text('identifier').notNull(), // email address
    value: text('value').notNull(), // verification token
    expiresAt: timestamp('expires_at').notNull(),
    createdAt: timestamp('created_at').notNull().defaultNow(),
    updatedAt: timestamp('updated_at').notNull().defaultNow(),
});
